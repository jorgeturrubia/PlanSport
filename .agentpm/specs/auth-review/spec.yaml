# ESTRUCTURA OBLIGATORIA - NO MODIFICAR
metadata:
  feature_name: auth-review
  created: 2025-08-15
  estimated_hours: 10
  priority: critical
  design_style: inherit-from .agentpm/project/design.yaml

git:
  branch_name: feature/auth-review
  base_branch: main

context:
  problem_statement: |
    - Cuando el usuario navega a /teams se desloguea o es redirigido a /auth/login aunque estaba autenticado.
    - Se requiere garantizar: si está autenticado -> dashboard (o ruta protegida), si no -> login.
    - Revisar tokens (access/refresh), persistencia, refresco automático y validación.
  current_impl_summary:
    frontend:
      routes_file: ../src/front/SportPlanner/src/app/app.routes.ts
      guard_file: ../src/front/SportPlanner/src/app/core/guards/auth.guard.ts
      interceptor_file: ../src/front/SportPlanner/src/app/core/interceptors/token.interceptor.ts
      auth_service_file: ../src/front/SportPlanner/src/app/core/services/auth.service.ts
      notes:
        - authGuard espera a isLoading() mediante polling y usa isAuthenticated() basado en userSignal
        - initializeAuth() refresca token si hay access/refresh en localStorage, pero no reconstruye usuario
        - token.interceptor añade Authorization excepto en endpoints de Auth; ante 401 ejecuta logout()
        - rutas protegidas: layout con canActivate [authGuard] para dashboard, teams, profile
    backend:
      notes:
        - Endpoints bajo /api/Auth (mayúscula A). Refresh devuelve nuevos tokens, no usuario

objectives:
  - Enrutado coherente: usuario autenticado accede a /dashboard y /teams sin ser expulsado
  - Sesión robusta: reconstruir estado de usuario al iniciar (post-refresh) y programar refresh anticipado
  - Validación de token: endpoint /api/Auth/verify o estrategia equivalente para verificar validez y expiración
  - Manejo de 401: intentar refresh silencioso una vez antes de forzar logout
  - Redirecciones claras: recordar redirectUrl al proteger rutas y aplicarla tras login

acceptance_criteria:
  - Dado un usuario con tokens válidos en localStorage, al refrescar la página en /teams permanece en /teams
  - Dado un access token expirado y refresh válido, la app renueva tokens sin salir a login y continúa la navegación
  - Dado refresh inválido/expirado, la app redirige a /auth/login limpiando estado
  - Navegar manualmente a rutas protegidas sin sesión lleva a /auth/login
  - Los endpoints no Auth incluyen Authorization: Bearer <access_token>

scope:
  in:
    - Guard y flujo de inicialización de sesión en frontend
    - Interceptor HTTP: reintento con refresh en 401 (una vez)
    - Nuevo endpoint backend /api/Auth/verify (si no existe) y ajuste de /refresh
    - Pruebas de navegación y de servicios
  out:
    - UI de registro/login (se mantiene)
    - Roles/ACL detallados

routing_changes:
  files_to_modify:
    - ../src/front/SportPlanner/src/app/app.routes.ts
  rules:
    - Asegurar canActivate/canMatch en todas las rutas protegidas bajo dashboard layout
    - Redirigir '' a 'dashboard' si autenticado; en landing pública mantener acceso

frontend_changes:
  auth_guard:
    improve_loading_strategy: true  # eliminar polling por init resolver o app initializer
    use_canMatch: true              # opcional para protección a nivel de módulo
  auth_service:
    add_loadUser_on_refresh: true
    add_verify_on_boot: true
    robust_redirect_handling: true
  interceptor:
    add_401_refresh_retry_once: true

backend_changes:
  add_verify_endpoint: true
  refresh_returns_user: true  # opcional para evitar llamada extra

testing:
  unit:
    - AuthService: login, refresh, verify, logout
    - token.interceptor: añadir header, reintento tras 401
    - auth.guard: comportamiento con loading/authenticated/unauthenticated
  e2e:
    - Flujo: login -> navegar a /teams -> recargar -> permanecer
    - Flujo: expirar access -> refresh válido -> request ok sin logout
    - Flujo: refresh inválido -> redirección a /auth/login

risks:
  - Bucles de refresh en cascada si no se controla el reintento
  - Desfase entre reloj cliente/servidor para expiración
  - Inconsistencia si backend usa "Auth" (mayúscula) y frontend filtra por paths distintos

metrics:
  - Tasa de 401 tras login < 1%
  - Tiempo medio de primera navegación protegida < 300ms tras boot
  - Cero redirecciones inesperadas en navegación estándar

