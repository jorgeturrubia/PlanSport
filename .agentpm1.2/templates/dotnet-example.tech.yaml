# .NET Technical Specification for LLM Code Generation
# Version: 1.0
# Purpose: LLM-only consumption for precise API/backend code generation

project:
  name: [PROJECT_NAME]
  type: [WebAPI/MVC/Blazor]
  created: [YYYY-MM-DD]
  
stack:
  dotnet:
    version: [8.x.x]
    target_framework: net8.0
    sdk_version: [8.0.x]
  csharp: [12.0]
  database: [postgres/sqlserver/mysql]
  hosting: [IIS/Kestrel/Docker]
  
dependencies:
  packages:
    # Core
    Microsoft.AspNetCore.App: [8.x.x]
    Microsoft.EntityFrameworkCore: [8.x.x]
    Microsoft.EntityFrameworkCore.Design: [8.x.x]
    Microsoft.EntityFrameworkCore.Tools: [8.x.x]
    
    # Database Providers
    [Npgsql.EntityFrameworkCore.PostgreSQL]: [8.x.x]
    
    # Authentication
    [Microsoft.AspNetCore.Authentication.JwtBearer]: [8.x.x]
    [Supabase]: [x.x.x]
    
    # API Documentation
    Swashbuckle.AspNetCore: [6.x.x]
    
    # Utilities
    AutoMapper: [12.x.x]
    FluentValidation: [11.x.x]
    Serilog: [3.x.x]
    MediatR: [12.x.x]
    
    # Testing
    xUnit: [2.x.x]
    Moq: [4.x.x]
    FluentAssertions: [6.x.x]
    
architecture:
  pattern: [clean-architecture/n-tier/vertical-slice]
  api_style: [REST/GraphQL]
  
  structure:
    src:
      API:                    # Presentation Layer
        Controllers:          # API endpoints
        Middleware:           # Custom middleware
        Filters:              # Action filters
        Program.cs:           # Entry point
        appsettings.json:     # Configuration
      Application:            # Business Logic Layer
        Services:             # Business services
        DTOs:                 # Data Transfer Objects
        Interfaces:           # Service contracts
        Validators:           # FluentValidation rules
        Mappings:             # AutoMapper profiles
        Commands:             # CQRS commands
        Queries:              # CQRS queries
      Domain:                 # Domain Layer
        Entities:             # Domain entities
        ValueObjects:         # Value objects
        Enums:                # Domain enums
        Interfaces:           # Repository interfaces
        Events:               # Domain events
      Infrastructure:         # Data Access Layer
        Data:
          Context:            # DbContext
          Configurations:     # Entity configurations
          Migrations:         # Database migrations
          Repositories:       # Repository implementations
        Services:             # External services
        Identity:             # Authentication/Authorization
      Shared:                 # Cross-cutting concerns
        Constants:            # Application constants
        Exceptions:           # Custom exceptions
        Extensions:           # Extension methods
        Utilities:            # Helper classes
        
auth:
  type: [JWT/Cookie/OAuth]
  provider: [Supabase/Auth0/IdentityServer/Custom]
  
  jwt:
    issuer: [https://api.example.com]
    audience: [api.example.com]
    secret_key: [JWT_SECRET_KEY]
    expiration_minutes: [60]
    refresh_expiration_days: [7]
    
  policies:
    - name: [AdminOnly]
      requirements: [Role:Admin]
    - name: [OwnerOnly]
      requirements: [User:Owner]
    - name: [PremiumSubscription]
      requirements: [Subscription:Premium]
      
  roles:
    - Admin
    - Director
    - Trainer
    - User
    
database:
  provider: [EntityFrameworkCore]
  database_type: [PostgreSQL]
  connection_string: [Server=localhost;Database=sportplanner;User Id=user;Password=pass;]
  
  configuration:
    lazy_loading: [false]
    change_tracking: [true]
    query_splitting: [true]
    use_snake_case: [true]
    
  migrations:
    location: Infrastructure/Data/Migrations
    auto_migrate: [false]
    
  seeding:
    enabled: [true]
    location: Infrastructure/Data/Seeders
    
  entities:
    [User]:
      properties:
        Id: Guid
        Email: string
        CreatedAt: DateTime
        UpdatedAt: DateTime
      relations:
        Subscriptions: one-to-many
        Teams: many-to-many
    [Subscription]:
      properties:
        Id: Guid
        Type: SubscriptionType
        ExpiresAt: DateTime
      relations:
        User: many-to-one
    # Add more entities as needed
    
api:
  versioning:
    enabled: [true]
    default_version: [1.0]
    header_name: [api-version]
    
  documentation:
    swagger:
      enabled: [true]
      title: [SportPlanner API]
      version: [v1]
      description: [API for SportPlanner application]
      
  cors:
    enabled: [true]
    allowed_origins:
      - [http://localhost:4200]
      - [https://app.sportplanner.com]
    allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]
    allowed_headers: [*]
    
  rate_limiting:
    enabled: [true]
    window_seconds: [60]
    permit_limit: [100]
    
  response_format:
    wrapper:
      success: |
        {
          "success": true,
          "data": { },
          "message": null
        }
      error: |
        {
          "success": false,
          "data": null,
          "message": "Error message",
          "errors": [ ]
        }
    
  endpoints:
    naming: [kebab-case/PascalCase]
    prefix: [api/v{version}]
    
validation:
  framework: FluentValidation
  
  rules:
    email: [EmailAddress, NotEmpty]
    password: [MinimumLength(8), Matches(regex)]
    required: [NotEmpty, NotNull]
    
  error_messages:
    NotEmpty: "El campo {PropertyName} es requerido"
    EmailAddress: "El formato del email no es válido"
    MinimumLength: "El campo {PropertyName} debe tener al menos {MinLength} caracteres"
    MaximumLength: "El campo {PropertyName} no puede exceder {MaxLength} caracteres"
    
logging:
  framework: Serilog
  
  sinks:
    - Console
    - File
    - [Seq/ElasticSearch]
    
  levels:
    Default: Information
    Microsoft: Warning
    System: Warning
    
  structured:
    enabled: [true]
    properties:
      - RequestId
      - UserId
      - CorrelationId
      
caching:
  provider: [InMemory/Redis/SqlServer]
  
  configuration:
    default_expiration_minutes: [30]
    sliding_expiration: [true]
    
  strategies:
    - Users: [5 minutes]
    - Teams: [10 minutes]
    - Plannings: [15 minutes]
    
testing:
  framework: xUnit
  
  structure:
    unit_tests:
      location: tests/UnitTests
      naming: [ClassName]Tests
    integration_tests:
      location: tests/IntegrationTests
      database: InMemory
    
  coverage:
    minimum: [60%]
    exclude:
      - Migrations
      - Program.cs
      - DTOs
      
error_handling:
  global_handler: [true]
  
  exceptions:
    NotFoundException: 404
    ValidationException: 400
    UnauthorizedException: 401
    ForbiddenException: 403
    ConflictException: 409
    BusinessException: 422
    
  messages:
    404: "Recurso no encontrado"
    400: "Solicitud inválida"
    401: "No autorizado"
    403: "Acceso denegado"
    500: "Error interno del servidor"
    
performance:
  async_await: [always]
  
  pagination:
    default_page_size: [20]
    max_page_size: [100]
    
  query_optimization:
    use_projection: [true]
    use_includes: [explicit]
    use_split_query: [true]
    
  response_compression:
    enabled: [true]
    algorithms: [gzip, brotli]
    
conventions:
  naming:
    classes: PascalCase
    interfaces: IPascalCase
    methods: PascalCase
    properties: PascalCase
    private_fields: _camelCase
    constants: UPPER_CASE
    
  files:
    controllers: [Name]Controller.cs
    services: [Name]Service.cs
    repositories: [Name]Repository.cs
    entities: [Name].cs
    dtos: [Name]Dto.cs
    validators: [Name]Validator.cs
    
  code_style:
    use_var: [when_obvious]
    use_expression_body: [when_simple]
    use_file_scoped_namespaces: [true]
    use_global_usings: [true]
    use_nullable_reference_types: [true]
    
patterns:
  controller_structure: |
    [ApiController]
    [Route("api/v{version:apiVersion}/[controller]")]
    [ApiVersion("1.0")]
    [Authorize]
    public class NameController : ControllerBase
    {
        private readonly INameService _service;
        private readonly ILogger<NameController> _logger;
        
        public NameController(INameService service, ILogger<NameController> logger)
        {
            _service = service;
            _logger = logger;
        }
        
        [HttpGet]
        public async Task<ActionResult<IEnumerable<NameDto>>> GetAll()
        {
            var result = await _service.GetAllAsync();
            return Ok(result);
        }
    }
    
  service_structure: |
    public class NameService : INameService
    {
        private readonly INameRepository _repository;
        private readonly IMapper _mapper;
        private readonly ILogger<NameService> _logger;
        
        public NameService(
            INameRepository repository,
            IMapper mapper,
            ILogger<NameService> logger)
        {
            _repository = repository;
            _mapper = mapper;
            _logger = logger;
        }
        
        public async Task<IEnumerable<NameDto>> GetAllAsync()
        {
            var entities = await _repository.GetAllAsync();
            return _mapper.Map<IEnumerable<NameDto>>(entities);
        }
    }
    
  repository_structure: |
    public class NameRepository : INameRepository
    {
        private readonly AppDbContext _context;
        
        public NameRepository(AppDbContext context)
        {
            _context = context;
        }
        
        public async Task<IEnumerable<Name>> GetAllAsync()
        {
            return await _context.Names
                .Where(x => !x.IsDeleted)
                .OrderBy(x => x.CreatedAt)
                .ToListAsync();
        }
    }
    
  entity_structure: |
    public class Name : BaseEntity
    {
        public Guid Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
        
        // Navigation properties
        public virtual ICollection<RelatedEntity> RelatedEntities { get; set; } = new List<RelatedEntity>();
    }
    
  dto_structure: |
    public record NameDto
    {
        public Guid Id { get; init; }
        public string Title { get; init; } = string.Empty;
        public DateTime CreatedAt { get; init; }
    }
    
  validator_structure: |
    public class NameValidator : AbstractValidator<NameDto>
    {
        public NameValidator()
        {
            RuleFor(x => x.Title)
                .NotEmpty().WithMessage("El título es requerido")
                .MaximumLength(100).WithMessage("El título no puede exceder 100 caracteres");
        }
    }
    
  configuration_structure: |
    public class NameConfiguration : IEntityTypeConfiguration<Name>
    {
        public void Configure(EntityTypeBuilder<Name> builder)
        {
            builder.ToTable("names");
            
            builder.HasKey(x => x.Id);
            
            builder.Property(x => x.Title)
                .IsRequired()
                .HasMaxLength(100);
                
            builder.HasIndex(x => x.Title);
        }
    }

commands:
  build: dotnet build
  run: dotnet run
  test: dotnet test
  publish: dotnet publish -c Release
  
  ef:
    add_migration: dotnet ef migrations add [MigrationName]
    update_database: dotnet ef database update
    remove_migration: dotnet ef migrations remove
    
  restore: dotnet restore
  clean: dotnet clean
  
security:
  authentication:
    scheme: Bearer
    validate_issuer: [true]
    validate_audience: [true]
    validate_lifetime: [true]
    
  authorization:
    use_policies: [true]
    use_roles: [true]
    use_claims: [true]
    
  data_protection:
    encrypt_sensitive: [true]
    use_https_only: [true]
    
  headers:
    X-Content-Type-Options: nosniff
    X-Frame-Options: DENY
    X-XSS-Protection: 1; mode=block
    Strict-Transport-Security: max-age=31536000
    
  secrets:
    storage: [UserSecrets/AzureKeyVault/Environment]
    prefix: [SPORTPLANNER_]
    
deployment:
  docker:
    enabled: [true]
    base_image: mcr.microsoft.com/dotnet/aspnet:8.0
    expose_port: [80, 443]
    
  environment_variables:
    ASPNETCORE_ENVIRONMENT: [Development/Staging/Production]
    ConnectionStrings__DefaultConnection: [connection_string]
    Jwt__Secret: [jwt_secret]
    
# LLM INSTRUCTIONS:
# - Use this YAML as source of truth for all .NET code generation
# - All patterns must be followed exactly  
# - Replace [PLACEHOLDERS] with actual values
# - Follow C# naming conventions strictly
# - Always use async/await for I/O operations
# - Implement proper error handling and logging
# - Use dependency injection for all services
# - Follow RESTful API conventions
# - Validate all inputs using FluentValidation
# - Map entities to DTOs using AutoMapper
# - Use Entity Framework Core with code-first approach
# - Implement repository pattern with generic base
# - All responses should be wrapped in standard format
# - All error messages should be in Spanish
# - Use structured logging with Serilog
# - Implement unit tests for all business logic
# - Follow clean architecture principles